//##################################################
//#
//#           ** DO NOT EDIT THIS FILE **
//#
//##################################################
//# Version: 2023-04-04b
'use strict';


var $jwt = require('jsonwebtoken');

module.exports = function ($elmer, oSecurityConfig) {
    //# Process the passed oSecurityConfig into an object with any default values applied
    oSecurityConfig = $elmer.extend(
        {                           //# Expected shape of the JWT config
            //mode: "jwt",              //# Inferred
            salt: {
                //localSecret: "",      //# Not used below
                jwtSecret: "",          //# TODO: Set a default salt?
                public: {
                    admin: "",
                    internal: "",
                    external: ""
                }
            },
            admin: [],
            internal: [],
            external: []
        },
        $elmer.resolve($elmer.app.config, "security.jwt"),
        oSecurityConfig //$elmer.resolve($router, "elmer.security")
    );

    //#
    $elmer.app.services.security.jwt = {
        defaultError: function () {
            return {
                method: 'jwt',
                error: 'Incorrect username/password combination.'
            };
        },

        verify: function (oJWT) {
            return $jwt.verify(oJWT, $elmer.app.config.security.jwt.salt.jwtSecret)
        },

        loginRouter: function () {
            let $router = $elmer.app.services.web.router();

            //# If this is .baseElmer, we need to enable the .json $bodyParser
            //#     NOTE: As the $bodyParser consumes the posted body, we must exclude any proxied routes (of which /login is not one)
            //#     SEE: https://stackoverflow.com/questions/28371641/how-can-i-use-express-http-proxy-after-bodyparser-json-has-been-called
            if ($elmer.app.config.baseElmer) {
                let $bodyParser = require("body-parser");

                $elmer.app.services.web.server.use("/login", $bodyParser.json({
                    type: "*/*",
                    //inflate: true,
                    limit: '1mb'
                }));
            }

            //#
            require(__dirname + "/../middleware/_jwt.js")($elmer, null);


            //# curl -X POST http://localhost:45000/login/admin -H 'Content-Type: application/json' -d '{ "username":"cn", "password":"secret" }'
            $router.post("/admin", async (oRequest, oResponse) => {
                $elmer.app.services.security.jwt.login(oRequest, oResponse, $elmer.app.enums.userTypes.admin);
            }); //# /login/admin


            //#
            $router.post("/internal", async (oRequest, oResponse) => {
                $elmer.app.services.security.jwt.login(oRequest, oResponse, $elmer.app.enums.userTypes.internal);
            }); //# /login/internal


            //#
            $router.post("/", async (oRequest, oResponse) => {
                $elmer.app.services.security.jwt.login(oRequest, oResponse, $elmer.app.enums.userTypes.external);
            }); //# /login


            //# curl -X POST http://localhost:45000/login/verify/admin -H 'Content-Type: application/json' -d '{ "jwt":"JWT_GOES_HERE" }'
            $router.post("/verify/:mode", async (oRequest, oResponse) => {
                //# Return the result of $jwt.verify
                oResponse.status(200).json(
                    $elmer.app.services.security.jwt.verify($elmer.resolve(oRequest.body, "jwt"))
                );
            }); //# /login/verify


            //#
            $router.all('*', async (oRequest, oResponse) => {
                oResponse.status(401).json($elmer.app.services.security.jwt.defaultError());
            }); //# /login/*

            return $router;
        }, //# loginRouter

        login: async function login(oRequest, oResponse, eMode) {
            let oJWTConfig, oUser, i,
                oBody = $elmer.type.obj.mk(oRequest.body, null),
                oReturnVal = $elmer.app.services.security.jwt.defaultError()
            ;

            //# In order to avoid crypto timing attacks, use the decimal part of process.uptime to randomly and slightly delay processing of the oBody
            //#     NOTE: This is arguably security through obscurity, but as it's based on process.uptime its random by definition.
            setTimeout(
                function () {
                    //# Determine the eMode, setting the oJWTConfig accordingly
                    switch (eMode) {
                        case $elmer.app.enums.userTypes.admin: {
                            oJWTConfig = {
                                salt: oSecurityConfig.salt.public.admin,
                                users: oSecurityConfig.admin,
                                expiresIn: "1 hours"
                            };
                            break;
                        }
                        case $elmer.app.enums.userTypes.internal: {
                            oJWTConfig = {
                                salt: oSecurityConfig.salt.public.internal,
                                users: oSecurityConfig.internal,
                                expiresIn: "8 hours"
                            };
                            break;
                        }
                        case $elmer.app.enums.userTypes.external: {
                            oJWTConfig = {
                                salt: oSecurityConfig.salt.public.external,
                                users: oSecurityConfig.external,
                                expiresIn: "8 hours"
                            };
                            break;
                        }
                    }

                    //# If we have a posted .body, a valid oJWTConfig and a valid .jwtSecret
                    if (oBody && oJWTConfig && $elmer.type.arr.is(oJWTConfig.users, true) && $elmer.type.str.is(oSecurityConfig.salt.jwtSecret, true)) {
                        //# Verify the username/password
                        for (i = 0; i < oJWTConfig.users.length; i++) {
                            //# If the current .u(sername) and .p(assword) match, set our oUser and fall from the loop
                            if ($elmer.type.obj.is(oJWTConfig.users[i]) &&
                                oBody.username === oJWTConfig.users[i].u &&
                                oBody.password === oJWTConfig.users[i].p
                            ) {
                                oUser = $elmer.extend({}, oJWTConfig.users[i]);
                                break;
                            }
                        }

                        //# If the username/password was correct, reset our oReturnVal to the oUser
                        if (oUser) {
                            oReturnVal = $elmer.extend(
                                oUser,
                                { p: undefined },
                                {
                                    jwt: $jwt.sign(
                                        {
                                            username: oUser.u,
                                            role: eMode
                                        },
                                        oSecurityConfig.salt.jwtSecret,
                                        {
                                            expiresIn: oJWTConfig.expiresIn
                                        }
                                    )
                                }
                            );
                        }
                    }
console.log("Login: ", oReturnVal.jwt, oSecurityConfig.salt.jwtSecret);

                    oResponse.status(oUser ? 200 : 401).json(oReturnVal);
                },
                Math.floor((process.uptime() % 1) * 100)
            );
        } //# login
    };


    //#
    return function (oRequest, oResponse, fnContinue) {
        let sAuth = $elmer.resolve(oRequest, "headers.authorization") || $elmer.resolve(oRequest, "cookies.auth"),
            bIsLocalRequest = false //$elmer.type.str.cmp($elmer.resolve(oRequest, "headers.origin"), ["127.0.0.1", "localhost"])
        ;

        //# If an .authorization .headers is present
        if ($elmer.type.str.is(sAuth, true)) {
            //# If this bIsLocalRequest, ensure the sAuth is valid
            if (bIsLocalRequest) {
                if (sAuth === oSecurityConfig.salt.localSecret) {
                    oRequest.user = { local: true };
                }
                //# Else sAuth wasn't the .localSecret, so return Unauthorized (401) and an .error
                else {
                    return oResponse.status(401).json({
                        method: "jwt",
                        error: 'Authentication required.'
                    });
                }
            }
            //# Else this is not bIsLocalRequest, so try to .verify the JWT token
            else {
console.log("Test: ", sAuth, oSecurityConfig.salt.jwtSecret);
                try {
                    //# .verify the JWT token, setting it into oRequest.user
                    oRequest.user = $jwt.verify(sAuth, oSecurityConfig.salt.jwtSecret);
                }
                catch (e) {
                    //# .verify failed, so return Unauthorized (401) and an .error
                    return oResponse.status(401).json({
                        method: "jwt",
                        error: 'Authentication required.'
                    });
                }
            }
        }
        //# Else the .authorization .headers is missing, so return Unauthorized (401) and an .error
        else {
            return oResponse.status(401).json({
                method: "jwt",
                error: 'Authorization cannot be empty.'
            });
        }

        fnContinue();
    };
}; //# module.exports
