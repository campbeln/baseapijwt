//##################################################
//#
//#           ** DO NOT EDIT THIS FILE **
//#
//##################################################
//# Version: 2023-04-09
'use strict';


//# Set the .exports to the Elmer route function definition
module.exports = function($elmer, $router /*, $baseRouter */) {
    //# Setup the required .app.data.proxy variables
    $elmer.app.data.proxy = [];
    $elmer.app.data.proxy.disallowed = ["", "login", "elmer"];


    //# /elmer/proxy route to allow the registration of Child APIs
    $router.post("/proxy", async (oRequest, oResponse) => {
        let fnLoginRouter,
            oBody = $elmer.type.obj.mk(oRequest.body),
            sRouteName = $elmer.type.str.mk(oBody.route).toLowerCase(),
            oRoute = $elmer.type.query($elmer.app.data.proxy, { route: sRouteName }, { firstEntryOnly: true }),
            oConfig = $elmer.type.obj.mk(oBody.config),
            bSecure = $elmer.type.obj.is(oConfig.security, true) && $elmer.type.str.is(oConfig.security.mode, true),
            bSuccess = false
        ;

        //#
        //oBody.server = ($elmer.io.net.ip.is(oBody.server) ? oBody.server : "0.0.0.0") || "0.0.0.0";

        //# If an existing oRoute was found above
        if ($elmer.type.obj.is(oRoute)) {
            //# If we are to .force the registration over the existing oRoute, flip bSuccess and reset the values within oRoute
            if ($elmer.type.bool.mk(oBody.force, false) /* oBody.force === oRoute.id */) {
                bSuccess = true;
                //oRoute.route = oRoute.route;
                oRoute.secure = bSecure;
                oRoute.config = oConfig;
                //router: oRoute.router,
                oRoute.server = oBody.server;
                oRoute.port = oBody.port;
                oRoute.instance++;
                //oRoute.id = $elmer.type.uuid();
            }
        }
        //# Else if the sRouteName is not within the .disallowed list, flip bSuccess and setup our new oRoute
        else if ($elmer.app.data.proxy.disallowed.indexOf(sRouteName) === -1) {
            bSuccess = true;
            oRoute = {
                route: sRouteName,
                secure: bSecure,
                config: oConfig,
                //router: undefined,
                server: oBody.server,
                port: oBody.port,
                instance: 1,
                id: $elmer.type.uuid()
            };
        }

        //# If the oRoute was bSuccess(fully) set above, .register it
        if (bSuccess) {
            //# .extend our oRoute based on the results of the .register(ation)
            oRoute = $elmer.extend(
                oRoute,
                $elmer.app.services.web.router.register(
                    sRouteName,
                    oRoute.server + ":" + oRoute.port,
                    oConfig
                )
            );

            //# If this proxy oRoute is bSecure
            if (bSecure) {
                //# .resolve the .loginRouter for the current .security.mode (if any)
                //#     NOTE: Due to the bSecure test above, we know that .security.mode .is a .str so it's safe to .trim().toLowerCase() it
                fnLoginRouter = $elmer.resolve($elmer.app.services.security, oConfig.security.mode.trim().toLowerCase() + ".loginRouter");

                //# If there's .loginRouter function for our .mode, .register them
                if ($elmer.type.fn.is(fnLoginRouter)) {
                    $elmer.app.services.web.router.register(
                        sRouteName + "/login",
                        fnLoginRouter()
                        //, {}
                    );
                }
            }
        }

        oResponse.status(bSuccess ? $elmer.io.net.status.success.ok : $elmer.io.net.status.clientError.conflict).json(oRoute);
    });


    //# TODO: Remove
    $router.get("/proxy", async (oRequest, oResponse) => {
        let oQuerystring = oRequest.querystring,
            sRouteName = $elmer.type.str.mk(oQuerystring.route).toLowerCase(),
            oRoute = $elmer.type.query($elmer.app.data.proxy, { route: sRouteName }, { firstEntryOnly: true }),
            bSuccess = false
        ;

        //#
        //oQuerystring.ip = ($elmer.io.net.ip.is(oQuerystring.ip) ? oQuerystring.ip : "0.0.0.0") || "0.0.0.0";

        //#
        if ($elmer.type.obj.is(oRoute)) {
            //#
            if ($elmer.type.bool.mk(oQuerystring.force, false) /* oQuerystring.force === oRoute.id */) {
                bSuccess = true;
                oRoute.ip = oQuerystring.ip;
                oRoute.port = oQuerystring.port;
                oRoute.instance++;
                //oRoute.id = $elmer.type.uuid();
            }
        }
        //#
        else if ($elmer.app.data.proxy.disallowed.indexOf(sRouteName) === -1) {
            bSuccess = true;
            oRoute = {
                route: sRouteName,
                ip: oQuerystring.ip,
                port: oQuerystring.port,
                instance: 1,
                id: $elmer.type.uuid()
            };
        }

        //#
        if (bSuccess) {
            //#
            oRoute = $elmer.extend(oRoute, $elmer.app.services.web.router.register(
                sRouteName,
                oRoute.ip + ":" + oRoute.port,
                {} // $elmer.type.bool.mk(oQuerystring.secure, true)
            ));
            //console.log(oRoute.ip, ":" + oRoute.port, sRouteName);
        }

        oResponse.status(bSuccess ? $elmer.io.net.status.success.ok : $elmer.io.net.status.clientError.conflict).json(oRoute);
    });


    //#
    $router.get('/cache/:route', async (oRequest, oResponse) => {
        let sRoute = oRequest.params.route,
            iStatus = ($elmer.type.obj.is($elmer.resolve($elmer, ["cache", sRoute])) ? 200 : 404)
        ;

        oResponse.status(iStatus).json({
            route: sRoute,
            data: $elmer.cache[sRoute]
        });
    });


    //#
    $router.get('/cache/:route/:subroute', async (oRequest, oResponse) => {
        let sRoute = oRequest.params.route,
            sSubroute = oRequest.params.subroute,
            iStatus = ($elmer.type.obj.is($elmer.resolve($elmer, ["cache", sRoute, sSubroute])) ? 200 : 404)
        ;

        oResponse.status(iStatus).json({
            route: sRoute,
            subroute: sSubroute,
            data: $elmer.cache[sRoute][sSubroute]
        });
    });


    //#
    $router.get('/cache/:route/:subroute/:last', async (oRequest, oResponse) => {
        let i,
            a_oData = [],
            sRoute = oRequest.params.route,
            sSubroute = oRequest.params.subroute,
            iLast = $elmer.type.int.mk(oRequest.params.last, 1),
            a_oSubroute = $elmer.resolve($elmer, ["cache", sRoute, sSubroute]),
            iStatus = ($elmer.type.obj.is($elmer.resolve($elmer, ["cache", sRoute, sSubroute])) ? 200 : 404)
        ;

        //#
        if (iStatus === 200) {
            for (i = a_oSubroute.length - iLast; i < a_oSubroute.length; i++) {
                a_oData.push(a_oSubroute[i]);
            }
        }

        oResponse.status(iStatus).json({
            route: sRoute,
            subroute: sSubroute,
            data: a_oData
        });
    });


    //#
    $router.get('/cache/clear/:route', async (oRequest, oResponse) => {
        let sRoute = oRequest.params.route,
            iStatus = ($elmer.type.obj.is($elmer.resolve($elmer, ["cache", sRoute])) ? 200 : 404)
        ;

        //#
        delete $elmer.cache[sRoute];

        oResponse.status(iStatus).json({
            route: sRoute,
            cleared: (iStatus === 200)
        });
    });


    //#
    $router.get('/cache/clear/:route/:subroute', async (oRequest, oResponse) => {
        let i, dCurrentWhen,
            sRoute = oRequest.params.route,
            sSubroute = oRequest.params.subroute,
            dBefore = $elmer.type.date.mk(oRequest.querystring.before, null),
            a_oSubroute = $elmer.resolve($elmer, ["cache", sRoute, sSubroute]),
            iStatus = ($elmer.type.arr.is(a_oSubroute) ? 200 : 404)
        ;

        //# If we found our sRoute/sSubroute
        if (iStatus === 200) {
            //# If the caller passed in a dBefore cutoff date on the .querystring, traverse our a_oSubroute while .resolve'ing the dCurrentWhen as we go
            for (i = 0; i < a_oSubroute.length; i++) {
                dCurrentWhen = $elmer.type.date.mk($elmer.resolve(a_oSubroute[i], "when"), null);

                //# If the dCurrentWhen is dBefore our cutoff date, .splice it out of our a_oSubroute
                if (dCurrentWhen && $elmer.type.date.cmp(dCurrentWhen, dBefore) < 0) {
                    a_oSubroute.splice(i, 1);
                }
                //# TODO: neek
                //# Else we are to clear the entire sSubroute
                else {
                    delete $elmer.cache[sRoute][sSubroute];
                }
            }
        }

        oResponse.status(iStatus).json({
            route: sRoute,
            subroute: sSubroute,
            cleared: (iStatus === 200)
        });
    });


}; //# module.exports
